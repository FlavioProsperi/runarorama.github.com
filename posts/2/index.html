
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Higher Order</title>
  <meta name="author" content="Rúnar Bjarnason">

  
  <meta name="description" content="Last week I gave a talk on Purely Functional I/O at Scala.io in Paris. The slides for the talk are available here. In it I presented a data type for &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://runarorama.github.com/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Higher Order" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript" src="//use.typekit.net/fbs7fzv.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34544663-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <link href="/stylesheets/datatable.css" media="screen, projection" rel="stylesheet" type="text/css" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Higher Order</a></h1>
  
    <h2>Philosophy and functional programming.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="runarorama.github.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-01'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Last week I gave a talk on <em>Purely Functional I/O</em> at Scala.io in Paris. <a href="http://blog.higher-order.com/assets/scalaio.pdf">The slides for the talk are available here.</a> In it I presented a data type for <code>IO</code> that is supposedly a &ldquo;free monad&rdquo;. But the monad I presented is not exactly the same as <code>scalaz.Free</code> and some people have been asking me why there is a difference and what that difference means.</p>

<h2>IO as an application of Free</h2>

<p>The <code>Free</code> monad in Scalaz is given a bit like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And throughout the methods on <code>Free</code>, it is required that <code>F</code> is a <em>functor</em> because in order to get at the recursive step inside a <code>Suspend</code>, we need to <code>map</code> over the <code>F</code> somehow.</p>

<p>But the <code>IO</code> monad I gave in the talk looks more like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Req</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">I</span>,<span class="kt">A</span><span class="o">](</span><span class="n">req</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it could actually be stated as an application of <code>Free</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>, <span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">α</span><span class="o">)</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">I</span><span class="o">}})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So in a very superficial sense, this is how the <code>IO</code> monad relates to <code>Free</code>. The monad <code>IO[F,_]</code> for a given <code>F</code> is the free monad generated by the functor <code>(F[I], I =&gt; _)</code> for some type <code>I</code>. And do note that <em>this is a functor no matter what <code>F</code> is</em>.</p>

<h2>IO as equivalent to Free</h2>

<p>There is a deeper sense in which <code>IO</code> and <code>Free</code> are actually equivalent (more precisely, isomorphic). That is, there exists a transformation from one to the other and back again. Since the only difference between <code>IO</code> and <code>Free</code> is in the functors <code>F[_]</code> vs <code>∃I. (F[I], I =&gt; _)</code>, we just have to show that these two are isomorphic for any <code>F</code>.</p>

<h3>The Yoneda lemma</h3>

<p>There is an important result in category theory known as the <em>Yoneda lemma</em>. What it says is that if you have a function defined like this&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;then you certainly have a value of type <code>F[A]</code>. All you need is to pass the identity function to <code>map</code> in order to get the value of type <code>F[A]</code> out of this function. In fact, a function like this is in practice probably defined as a method on a value of type <code>F[A]</code> anyway. This also means that <code>F</code> is definitely a functor.</p>

<p>The Yoneda lemma says that this goes the other way around as well. If you have a value of type <code>F[A]</code> for any functor <code>F</code> and any type <code>A</code>, then you certainly have a <code>map</code> function with the signature above.</p>

<p>In scala terms, we can capture this in a type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the Yoneda lemma says that there is an isomorphism between <code>Yoneda[F,A]</code> and <code>F[A]</code>, for any functor <code>F</code> and any type <code>A</code>. Here is the proof:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz._</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">toYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">froYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CoYoneda</h3>

<p>Of course, this also means that if we have a type <code>B</code>, a function of type <code>(B =&gt; A)</code> for some type <code>A</code>, and a value of type <code>F[B]</code> for some functor <code>F</code>, then we certainly have a value of type <code>F[A]</code>. This is kind of obvious, since we can just pass the <code>B =&gt; A</code> and the <code>F[B]</code> to the <code>map</code> function for the functor and get our <code>F[A]</code>.</p>

<p>But the opposite is also true, and that is the really interesting part. If we have a value of type <code>F[A]</code>, for any <code>F</code> and <code>A</code>, then we can always destructure it into a value of type <code>F[B]</code> and a function of type <code>B =&gt; A</code>, at least for <em>some</em> type <code>B</code>. And it turns out that we can do this even if <code>F</code> is not a functor.</p>

<p>This is the permutation of the Yoneda lemma that we were using in <code>IO</code> above. That is, <code>IO[F, A]</code> is really <code>Free[({type λ[α] = CoYoneda[F,α]})#λ, A]</code>, given:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the lemma says that <code>CoYoneda[F,A]</code> is isomorphic to <code>F[A]</code>. Here is the proof:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">toCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fi</span> <span class="k">=</span> <span class="n">fa</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">def</span> <span class="n">froCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">CoYo</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">yo</span><span class="o">.</span><span class="n">fi</span><span class="o">)(</span><span class="n">yo</span><span class="o">.</span><span class="n">f</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this destructuring into <code>CoYoneda</code> using the identity function is the simplest and most general, but there may be others for specific <code>F</code> and <code>A</code> depending on what we know about them.</p>

<p>So there you have it. The <code>scalaz.Free</code> monad with its <code>Suspend(F[Free[F,A]])</code> constructor and the <code>IO</code> monad with its <code>Req(F[I], I =&gt; IO[F,A])</code> constructor are actually equivalent. The latter is simply making use of <code>CoYoneda</code> to say the same thing.</p>

<p>Why bother? The useful part is that <code>CoYoneda[F,_]</code> is a functor for any <code>F</code>, so it&rsquo;s handy to use in a free monad since we can then drop the requirement that <code>F</code> is a functor. What&rsquo;s more, it gives us <em>map fusion</em> for free, since <code>map</code> over <code>CoYoneda</code> is literally just function composition on its <code>f</code> component. Although this latter is, in the absence of tail call elimination, not as useful as it could be in Scala.</p>

<p>I hope that sheds a little bit of light on the Yoneda lemma as well as the different embeddings of free monads.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/free-monads-and-free-monoids/">Free Monoids and Free Monads</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-20'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In a series of old posts, I once talked about the link between <a href="http://apocalisp.wordpress.com/2010/06/14/on-monoids/">lists and monoids</a>, as well as <a href="http://apocalisp.wordpress.com/2010/07/21/more-on-monoids-and-monads/">monoids and monads</a>. Now I want to talk a little bit more about monoids and monads from the perspective of <em>free structures</em>.</p>

<p><code>List</code> is a <em>free monoid</em>. That is, for any given type <code>A</code>, <code>List[A]</code> is a monoid, with list concatenation as the operation and the empty list as the identity element.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">freeMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span> <span class="k">=</span> <span class="nc">Nil</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">a1</span> <span class="o">++</span> <span class="n">a2</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Being a free monoid means that it&rsquo;s the <em>minimal</em> such structure. <code>List[A]</code> has exactly enough structure so that it is a monoid for any given <code>A</code>, and it has no further structure. This also means that for any given monoid <code>B</code>, there must exist a transformation, a <em>monoid homomorphism</em> from <code>List[A]</code> to <code>B</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given a mapping from <code>A</code> to a monoid <code>B</code>, we can collapse a value in the monoid <code>List[A]</code> to a value in <code>B</code>.</p>

<h2>Free monads</h2>

<p>Now, if you followed my old posts, you already know that monads are &ldquo;higher-kinded monoids&rdquo;. A monoid in a category where the objects are type constructors (functors, actually) and the arrows between them are natural transformations. As a reminder, a natural transformation from <code>F</code> to <code>G</code> can be represented this way in Scala:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">~&gt;</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it turns out that there is a free monad for any given functor <code>F</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Analogous to how a <code>List[A]</code> is either <code>Nil</code> (the empty list) or a product of a <code>head</code> element and <code>tail</code> list, a value of type <code>Free[F,A]</code> is either an <code>A</code> or a product of <code>F[_]</code> and <code>Free[F,_]</code>. It is a recursive structure. And indeed, it has <em>exactly enough structure</em> to be a monad, for any given <code>F</code>, and no more.</p>

<p>When I say &ldquo;product&rdquo; of two functors like <code>F[_]</code> and <code>Free[F,_]</code>, I mean a product like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">:*:</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we might expect that there is a <em>monad homomorphism</em> from a free monad on <code>F</code> to any monad that <code>F</code> can be transformed to. And indeed, it turns out that there is. The free monad catamorphism is in fact a monad homomorphism. Given a natural transformation from <code>F</code> to <code>G</code>, we can collapse a <code>Free[F,A]</code> to <code>G[A]</code>, just like with <code>foldMap</code> when given a function from <code>A</code> to <code>B</code> we could collapse a <code>List[A]</code> to <code>B</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">runFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Monad</span>,<span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what&rsquo;s the equivalent of <code>foldRight</code> for <code>Free</code>? Remember, foldRight takes a unit element <code>z</code> and a function that accumulates into <code>B</code> so that <code>B</code> doesn&rsquo;t actually have to be a monoid. Here, <code>f</code> is a lot like the monoid operation, except it takes the current <code>A</code> on the left:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The equivalent for <code>Free</code> takes a natural transformation as its unit element, which for a monad happens to be monadic <code>unit</code>. Then it takes a natural transformation as its <code>f</code> argument, that looks a lot like monadic <code>join</code>, except it takes the current <code>F</code> on the left:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">foldFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span>
</span><span class='line'>  <span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span>
</span><span class='line'>  <span class="n">z</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)(</span>
</span><span class='line'>  <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">F:*:G</span><span class="o">)</span><span class="k">#</span><span class="kt">λ</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, <code>G</code> does not have to be a monad at all.</p>

<p><code>Free</code> as well as natural transformations and product types are available in <a href="http://github.com/scalaz">Scalaz</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/26/machines/">Machines and Stream Processing</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-01-26T12:34:00-05:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:34 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I gave a talk on &ldquo;Machines&rdquo; and stream processing in <a href="https://github.com/ekmett/machines">Haskell</a> and <a href="https://github.com/runarorama/scala-machines">Scala</a>, to the <a href="http://www.bfpg.org/">Brisbane Functional Programming Group</a> at Microsoft HQ in December 2012. A lot of people have asked me for the slides, so here they are:</p>

<p><a href="https://dl.dropbox.com/u/4588997/Machines.pdf">Machines.pdf</a></p>

<p>The preëmptive answer to the usual follow-up question is that the talk was not recorded.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/13/what-purity-is-and-isnt/">What Purity Is and Isn&#8217;t</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-13T22:07:00-04:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>10:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A lot of discussion about &ldquo;purity&rdquo; goes on without participants necessarily having a clear idea of what it means exactly. Such discussion is generally unhelpful and distracting.</p>

<h3>What purity is</h3>

<p>The typical definition of purity (and the one we use in <a href="http://manning.com/bjarnason">our book</a>) goes something like this:</p>

<p>An expression <code>e</code> is <em>referentially transparent</em> if for all programs <code>p</code>, every occurrence of <code>e</code> in <code>p</code> can be replaced with the result of evaluating <code>e</code> without changing the result of evaluating <code>p</code>.</p>

<p>A function <code>f</code> is <em>pure</em> if the expression <code>f(x)</code> is referentially transparent for all referentially transparent <code>x</code>.</p>

<p>Now, something needs to be made clear right up front. Like all definitions, this holds in a specific <em>context</em>. In particular, the context needs to specify what &ldquo;evaluating&rdquo; means. It also needs to define &ldquo;program&rdquo;, &ldquo;occurrence&rdquo;, and the semantics of &ldquo;replacing&rdquo; one thing with another.</p>

<p>In a programming language like Haskell, Java, or Scala, this context is pretty well established. The process of evaluation is a reduction to some <em>normal form</em> such as weak head or beta normal form.</p>

<h3>A simple example</h3>

<p>To illustrate, let&rsquo;s consider programs in an exceedingly simple language that we will call <em>Sigma</em>. An expression in Sigma has one of the following forms:</p>

<ul>
<li>A literal character string like <code>"a"</code>, <code>"foo"</code>, <code>""</code>, etc.</li>
<li>A concatenation, <code>s + t</code>, for expressions <code>s</code> and <code>t</code>.</li>
<li>A special <code>Ext</code> expression that denotes input from an external source.</li>
</ul>


<p>Now, without an evaluator for Sigma, it is a purely abstract algebra. So let&rsquo;s define a straigtforward evaluator <code>eval</code> for it, with the following rules:</p>

<ul>
<li>A literal string is already in normal form.</li>
<li><code>eval(s + t)</code> first evaluates <code>s</code> and <code>t</code> and concatenates the results into one literal string.</li>
<li><code>eval(Ext)</code> reads a line from standard input and returns it as a literal string.</li>
</ul>


<p>This might seem very simple, but it is still not clear whether <code>Ext</code> is referentially transparent with regard to <code>eval</code>. It depends. What does &ldquo;reads a line&rdquo; mean, and what is &ldquo;standard input&rdquo; exactly? This is all part of a context that needs to be established.</p>

<p>Here&rsquo;s one implementation of an evaluator for Sigma, in Scala:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Ext</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">eval1</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">readLine</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, it&rsquo;s easy to see that the <code>Ext</code> instruction is <em>not</em> referentially transparent with regard to <code>eval1</code>. Replacing <code>Ext</code> with <code>eval1(ext)</code> does not preserve meaning. Consider this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Ext</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>VS this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="nc">Ext</span><span class="o">)</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s clearly not the same thing. The former will get two strings from standard input and concatenate them together. The latter will get only one string, store it as <code>x</code>, and return <code>x + x</code>.</p>

<p>Now consider a slightly different evaluator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">eval2</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">stdin</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, the <code>Ext</code> instruction clearly <em>is</em> referentially transparent with regard to <code>eval2</code>, because our standard input is just a string, and it is always the same string. So you see, the purity of functions in the Sigma language very much depends on how that language is interpreted.</p>

<p>This is the reason why Haskell programs are considered &ldquo;pure&rdquo;, even in the presence of <code>IO</code>. A value of type <code>IO a</code> in Haskell is simply a function. Reducing it to normal form (evaluating it) has no effect. An <code>IO</code> action is of course not referentially transparent with regard to <code>unsafePerformIO</code>, but as long as your program does not use that it remains a referentially transparent expression.</p>

<h3>What purity is not</h3>

<p>In my experience there are more or less two camps into which unhelpful views on purity fall.</p>

<p>The first view, which we will call the <em>empiricist</em> view, is typically taken by people who understand &ldquo;pure&rdquo; as a pretentious term, meant to denegrate regular everyday programming as being somehow &ldquo;impure&rdquo; or &ldquo;unclean&rdquo;. They see purity as being &ldquo;academic&rdquo;, detached from reality, in an ivory tower, or the like.</p>

<p>This view is premised on a superficial understanding of purity. The assumption is that purity is somehow about the absence of I/O, or not mutating memory. But how could any programs be written that don&rsquo;t change the state of memory? At the end of the day, you have to update the CPU&rsquo;s registers, write to memory, and produce output on a display. A program has to make the computer <em>do something</em>, right? So aren&rsquo;t we just pretending that our programs don&rsquo;t run on real computers? Isn&rsquo;t it all just an academic exercise in making the CPU warm?</p>

<p>Well, no. That&rsquo;s not what purity means. Purity is not about the absence of program behaviors like I/O or mutable memory. It&rsquo;s about delimiting such behavior in a specific way.</p>

<p>The other view, which I will call the <em>rationalist</em> view, is typically taken by people with overexposure to modern analytic philosophy. Expressions are to be understood by their <em>denotation</em>, not by reference to any evaluator. Then of course every expression is really referentially transparent, and so purity is a distinction without a difference. After all, an imperative side-effectful C program can have the same denotation as a monadic, side-effect-free Haskell program. There is nothing wrong with this viewpoint, but it&rsquo;s not instructive <em>in this context</em>. Sure, when designing in the abstract, we can think denotationally without regard to evaluation. But when concretizing the design in terms of an actual programming language, we do need to be aware of how we expect evaluation to take place. And only then are referential transparency and purity useful concepts.</p>

<p>Both of these, the rationalist and empiricist views, conflate different levels of abstraction. A program written in a programming language is not the same thing as the physical machine that it may run on. Nor is it the same thing as the abstractions that capture its meaning.</p>

<h3>Further reading</h3>

<p>I highly recommend the paper <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;sqi=2&amp;ved=0CCMQFjAB&amp;url=http%3A%2F%2Fwww.cs.indiana.edu%2F~sabry%2Fpapers%2FpurelyFunctional.ps&amp;ei=I5NYUIRUqvXSAbC_gKgF&amp;usg=AFQjCNGwxjzB5zUBws6D9wnKPzo-zL57pw&amp;sig2=HgE-ZhzoIS19TEe2K2EW-Q"><em>What is a Purely Functional Language?</em></a> by Amr Sabry, although it deals with the idea of a <em>purely functional language</em> rather than purity of functions within a language that does not meet that criteria.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/04/this-blog-has-moved/">New Beginnings</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-04T01:29:00-04:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>1:29 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I have not seriously updated the <a href="http://apocalisp.wordpress.com">old Apocalisp blog</a> for quite some time. Mostly this is due to the fact that I have been spending all of my creative time outside of work on <a href="http://manning.com/bjarnason">writing a book</a>. It&rsquo;s also partly that putting a post up on WordPress is a chore. It&rsquo;s like building a ship in a bottle.</p>

<p>So I have decided to make posting really easy for myself by hosting the blog <a href="http://github.com/runarorama/runarorama.github.com">on GitHub</a>. I am using a dead-simple markdown-based framework called <a href="http://octopress.org">Octopress</a>. With this setup I can very easily write a new post from my command line and publish by pushing to GitHub. This is already part of my normal coding workflow, so it feels more friction-free.</p>

<p>The new blog is simply titled &ldquo;Higher Order&rdquo;, and is available at <a href="http://blog.higher-order.com">blog.higher-order.com</a>. Check back soon for posts that I&rsquo;ve been sitting on but have been too <del>lazy</del> busy to post.</p>

<p>All of the old content and comments will still be available at the old address, and I&rsquo;ll probably cross-post to both places for a little while.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/14/scalaz-tutorial-enumeration-based-io-with-iteratees/">Scalaz Tutorial: Enumeration-based I/O With Iteratees</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-14'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://scalaz.org">Scalaz</a> 5.0 adds an implementation of a concept called Iteratee. This is a highly flexible programming technique for writing enumeration-based input processors that can be freely composed.</p>

<p>A lot of people have asked me to write a tutorial on how this works, specifically on how it is implemented in Scalaz and how to be productive with it, so here we go.</p>

<p>The implementation in Scalaz is based on an excellent article by John W. Lato called <a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf">“Iteratee: Teaching an Old Fold New Tricks”</a>. As a consequence, this post is also based on that article, and because I am too unoriginal to come up with my own examples, the examples are directly translated from it. The article gives code examples in Haskell, but we will use Scala here throughout.</p>

<h2>Motivation</h2>

<p>Most programmers have come across the problem of treating an I/O data source (such as a file or a socket) as a data structure. This is a common thing to want to do. To contrast, the usual means of reading, say, a file, is to open it, get a cursor into the file (such as a FileReader or an InputStream), and read the contents of the file as it is being processed. You must of course handle IO exceptions and remember to close the file when you are done. The problem with this approach is that it is not modular. Functions written in this way are performing one-off side-effects. And as we know, side-effects do not compose.</p>

<p>Treating the stream of inputs as an enumeration is therefore desirable. It at least holds the lure of modularity, since we would be able to treat a File, from which we’re reading values, in the same way that we would treat an ordinary List of values, for example.</p>

<p>A naive approach to this is to use iterators, or rather, Iterables. This is akin to the way that you would typically read a file in something like Ruby or Python. Basically you treat it as a collection of Strings:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">getContents</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fileName</span><span class="o">))</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">next</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">retVal</span> <span class="k">=</span> <span class="n">line</span>
</span><span class='line'>        <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>        <span class="n">retVal</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">getLine</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">line</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">line</span> <span class="k">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">readLine</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">line</span> <span class="k">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">line</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this is doing is a kind of lazy I/O. Nothing is read from the file until it is requested, and we only hold one line in memory at a time. But there are some serious issues with this approach. It’s not clear when you should close the file handle, or whose responsibility that is. You could have the Iterator close the file when it has read the last line, but what if you only want to read part of the file? Clearly this approach is not sufficient. There are some things we can do to make this more sophisticated, but only at the expense of breaking the illusion that the file really is a collection of Strings.</p>

<h2>The Idea</h2>

<p>Any red-blooded functional programmer should be thinking right about now: “Instead of getting Strings out of the file, just pass in a function that will serve as a handler for each new line!” Bingo. This is in fact the plot with Iteratees. Instead of implementing an interface from which we request Strings by pulling, we’re going to give an implementation of an interface that can receive Strings by pushing.</p>

<p>And indeed, this idea is nothing new. This is exactly what we do when we fold a list:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The second argument is exactly that, a handler for each element in the list, along with a means of combining it with the accumulated value so far.</p>

<p>Now, there are two issues with an ordinary fold that prevent it from being useful when enumerating file contents. Firstly, there is no way of indicating that the fold should stop early. Secondly, a list is held all in memory at the same time.</p>

<h2>The Iteratee Solution</h2>

<p>Scalaz defines the following two data structures (actual implementation may differ, but this serves for illustration):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">+E</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">El</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">EOF</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// Implementation omitted</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Done</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So an input to an iteratee is represented by Input[E], where E is the element type of the input source. It can be either an element (the next element in the file or stream), or it’s one of two signals: Empty or EOF. The Empty signal tells the iteratee that there is not an element available, but to expect more elements later. The EOF signal tells the iteratee that there are no more elements to be had.</p>

<p>Note that this particular set of signals is kind of arbitrary. It just facilitates a particular set of use cases. There’s no reason you couldn’t have other signals for other use cases. For example, a signal I can think of off the top of my head would be Restart, which would tell the iteratee to start its result from scratch at the current position in the input.</p>

<p>IterV[E,A] represents a computation that can be in one of two states. It can be Done, in which case it will hold a result (the accumulated value) of type A. Or it can be waiting for more input of type E, in which case it will hold a continuation that accepts the next input.</p>

<p>Let’s see how we would use this to process a List. The following function takes a list and an iteratee and feeds the list’s elements to the iteratee.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumerate</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">],</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let’s see some actual iteratees. As a simple example, here is an iteratee that counts the number of elements it has seen:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here’s an iteratee that discards the first n elements:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">Empty</span><span class="o">)</span> <span class="k">else</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And one that takes the first element from the input:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">head</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let’s go through this code. Each one defines a “step” function, which is the function that will handle the next input. Each one starts the iteratee in the Cont state, and the step function always returns a new iteratee in the next state based on the input received. Note in the last one (head), we are using the Empty signal to indicate that we want to remove the element from the input. The utility of this will be clear when we start composing iteratees.</p>

<p>Now, an example usage. To get the length of a list, we write:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">enumerate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="n">counter</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="n">run</span> <span class="c1">// 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>The run method on IterV just gets the accumulated value out of the Done iteratee. If it isn’t done, it sends the EOF signal to itself first and then gets the value.</p>

<h2>Composing Iteratees</h2>

<p>Notice a couple of things here. With iteratees, the input source can send the signal that it has finished producing values. And on the other side, the iteratee itself can signal to the input source that it has finished consuming values. So on one hand, we can leave an iteratee “running” by not sending it the EOF signal, so we can compose two input sources and feed them into the same iteratee. On the other hand, an iteratee can signal that it’s done, at which point we can start sending any remaining elements to another iteratee. In other words, iteratees compose sequentially.</p>

<p>In fact, IterV[E,A] is an instance of the Monad type class for each fixed E, and composition is very similar to the way monadic parsers compose:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here then is an example of composing iteratees with a for-comprehension:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">head</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>The iteratee above discards the first element it sees and returns the second one. The iteratee below does this n times, accumulating the kept elements into a list.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">alternates</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">].</span>
</span><span class='line'>    <span class="n">replicate</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">n</span><span class="o">).</span>
</span><span class='line'>    <span class="n">foldRight</span><span class="o">(</span><span class="nc">Done</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]](),</span><span class="nc">Empty</span><span class="o">))((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">h</span> <span class="k">&lt;-</span> <span class="n">x</span>
</span><span class='line'>      <span class="n">t</span> <span class="k">&lt;-</span> <span class="n">y</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here’s an example run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumerate(List.range(1,15), alternates[Int](5)).run
</span><span class='line'>res85: List[Int] = List(2, 4, 6, 8, 10)</span></code></pre></td></tr></table></div></figure>


<h2>File Input With Iteratees</h2>

<p>Using the iteratees to read from file input turns out to be incredibly easy. The only difference is in how the data source is enumerated, and in order to remain lazy (and not prematurely perform any side-effects), we must return our iteratee in a monad:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumReader</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">,</span>
</span><span class='line'>                  <span class="n">it</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">r</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
</span><span class='line'>      <span class="n">a</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span> <span class="k">else</span> <span class="n">loop</span><span class="o">(</span><span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">loop</span><span class="o">(</span><span class="n">it</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The monad being used here is an IO monad that I’ll explain in a second. The important thing to note is that the iteratee is completely oblivious to the fact that it’s being fed lines from a BufferedReader rather than a List.</p>

<p>Here is the IO monad I’m using. As you can see, it’s really just a lazy identity monad:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">io</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">unsafePerformIO</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">object</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">unsafePerformIO</span> <span class="k">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">IOMonad</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monad</span><span class="o">[</span><span class="kt">Function0</span><span class="o">]].</span><span class="n">bind</span><span class="o">(</span>
</span><span class='line'>        <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">unsafePerformIO</span><span class="o">,</span>
</span><span class='line'>        <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="n">unsafePerformIO</span><span class="o">)()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>To read lines from a file, we’ll do something like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">closeReader</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">bracket</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">fin</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">body</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'><span class="k">for</span> <span class="o">{</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">init</span>
</span><span class='line'>      <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">body</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">fin</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">enumFile</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">bracket</span><span class="o">(</span><span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="o">),</span>
</span><span class='line'>          <span class="n">closeReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">),</span>
</span><span class='line'>          <span class="n">enumReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The enumFile method uses bracketing to ensure that the file always gets closed. It’s completely lazy though, so nothing actually happens until you call unsafePerformIO on the resulting IO action:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumFile(new File("/Users/runar/Documents/Iteratees.txt"), head) map (_.run)                
</span><span class='line'>res2: io.IO[Option[String]] = io$IO@5f90b584
</span><span class='line'>
</span><span class='line'>scala> res2.unsafePerformIO
</span><span class='line'>res3: Option[String] = Some(Scalaz Tutorial: Enumeration-Based I/O With Iteratees)</span></code></pre></td></tr></table></div></figure>


<p>That uses the “head” iteratee from above to get the first line of the file that I’m using to edit this blog post.</p>

<p>We can get the number of lines in two files combined, by composing two enumerations and using our “counter” iteratee from above:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">lengthOfTwoFiles</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">f2</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span>
</span><span class='line'>  <span class="n">l2</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">l1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">l2</span><span class="o">.</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>So what we have here is a uniform and compositional interface for enumerating both pure and effectful data sources. We can avoid holding on to the entire input in memory when we don’t want to, and we have complete control over when to stop iterating. The iteratee can decide whether to consume elements, leave them intact, or even truncate the input. The enumerator can decide whether to shut the iteratee down by sending it the EOF signal, or to leave it open for other enumerators.</p>

<p>There is even more to this approach, as we can use iteratees not just to read from data sources, but also to write to them. That will have to await another post.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/08/21/structural-pattern-matching-in-java/">Structural Pattern Matching in Java</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2009-08-21'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2009</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>(updated for Java 8)</p>

<p>One of the great features of modern programming languages is structural pattern matching on algebraic data types. Once you&rsquo;ve used this feature, you don&rsquo;t ever want to program without it. You will find this in languages like Haskell and Scala.</p>

<p>In Scala, algebraic types are provided by case classes. For example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span></code></pre></td></tr></table></div></figure>


<p>To define operations over this algebraic data type, we use pattern matching on its structure:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">depth</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="mi">0</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When I go back to a programming language like, say, Java, I find myself wanting this feature. Unfortunately, algebraic data types aren&rsquo;t provided in Java. However, a great many hacks have been invented over the years to emulate it, knowingly or not.</p>

<h3>The Ugly: Interpreter and Visitor</h3>

<p>What I have used most throughout my career to emulate pattern matching in languages that lack it are a couple of hoary old hacks. These venerable and well respected practises are a pair of design patterns from the GoF book: Interpreter and Visitor.</p>

<p>The Interpreter pattern really does describe an algebraic structure, and it provides a method of reducing (interpreting) the structure. However, there are a couple of problems with it. The interpretation is coupled to the structure, with a &ldquo;context&rdquo; passed from term to term, and each term must know how to mutate the context appropriately. That&rsquo;s minus one point for tight coupling, and minus one for relying on mutation.</p>

<p>The Visitor pattern addresses the former of these concerns. Given an algebraic structure, we can define an interface with one &ldquo;visit&rdquo; method per type of term, and have each term accept a visitor object that implements this interface, passing it along to the subterms. This decouples the interpretation from the structure, but still relies on mutation. Minus one point for mutation, and minus one for the fact that Visitor is incredibly crufty. For example, to get the depth of our tree structure above, we have to implement a TreeDepthVisitor. A good IDE that generates boilerplate for you is definitely recommended if you take this approach.</p>

<p>On the plus side, both of these patterns provide some enforcement of the exhaustiveness of the pattern match. For example, if you add a new term type, the Interpreter pattern will enforce that you implement the interpretation method. For Visitor, as long as you remember to add a visitation method for the new term type to the visitor interface, you will be forced to update your implementations accordingly.</p>

<h3>The Bad: Instanceof</h3>

<p>An obvious approach that&rsquo;s often sneered at is runtime type discovery. A quick and dirty way to match on types is to simply check for the type at runtime and cast:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Empty</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Leaf</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Node</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(((</span><span class="n">Node</span><span class="o">)</span> <span class="n">t</span><span class="o">).</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(((</span><span class="n">Node</span><span class="o">)</span> <span class="n">t</span><span class="o">).</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;Inexhaustive pattern match on Tree.&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are some obvious problems with this approach. For one thing, it bypasses the type system, so you lose any static guarantees that it&rsquo;s correct. And there&rsquo;s no enforcement of the exhaustiveness of the matching. But on the plus side, it&rsquo;s both fast and terse.</p>

<h3>The Good: Functional Style</h3>

<p>There are at least two approaches that we can take to approximate pattern matching in Java more closely than the above methods. Both involve utilising parametric polymorphism and functional style. Let&rsquo;s consider them in order of increasing preference, i.e. less preferred method first.</p>

<h4>Safe and Terse - Disjoint Union Types</h4>

<p>The first approach is based on the insight that algebraic data types represent a disjoint union of types. Now, if you&rsquo;ve done any amount of programming in Java with generics, you will have come across (or invented) the simple pair type, which is a conjunction of two types:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">P2</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">A</span> <span class="nf">_1</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">B</span> <span class="nf">_2</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>A value of this type can only be created if you have both a value of type <code>A</code> and a value of type <code>B</code>. So (conceptually, at least) it has a single constructor that takes two values. The disjunction of two types is a similar idea, except that a value of type <code>Either&lt;A, B&gt;</code> can be constructed with either a value of type <code>A</code> or a value of type <code>B</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="nf">left</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="nf">right</span><span class="o">(</span><span class="n">B</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Encoded as a disjoint union type, then, our <code>Tree</code> data type above is: <code>Either&lt;Empty, Either&lt;Leaf, Node&gt;&gt;</code></p>

<p>Let&rsquo;s see that in context. Here&rsquo;s the code.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Constructor private so the type is sealed.</span>
</span><span class='line'>  <span class="kd">private</span> <span class="nf">Tree</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Empty</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">left</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Empty</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Leaf</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">right</span><span class="o">(</span><span class="n">Either</span><span class="o">.&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span><span class="n">left</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Leaf</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">left</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">right</span><span class="o">(</span><span class="n">Either</span><span class="o">.&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span><span class="n">right</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Tree</span> <span class="n">left</span><span class="o">,</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The neat thing is that <code>Either&lt;A, B&gt;</code> can be made to return both <code>Iterable&lt;A&gt;</code> and <code>Iterable&lt;B&gt;</code> in methods <code>right()</code> and <code>left()</code>, respectively. One of them will be empty and the other will have exactly one element. So our pattern matching function will look like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">eln</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">toEither</span><span class="o">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Empty</span> <span class="nl">e:</span> <span class="n">eln</span><span class="o">.</span><span class="na">left</span><span class="o">())</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="nl">ln:</span> <span class="n">eln</span><span class="o">.</span><span class="na">right</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="nl">leaf:</span> <span class="n">ln</span><span class="o">.</span><span class="na">left</span><span class="o">())</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="nl">node:</span> <span class="n">ln</span><span class="o">.</span><span class="na">right</span><span class="o">())</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;Inexhaustive pattern match on Tree.&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s terse and readable, as well as type-safe. The only issue with this is that the exhaustiveness of the patterns is not enforced, so we&rsquo;re still only discovering that error at runtime. So it&rsquo;s not all that much of an improvement over the instanceof approach.</p>

<h4>Safe and Exhaustive: Church Encoding</h4>

<p>Alonzo Church was a pretty cool guy. Having invented the lambda calculus, he discovered that you could encode data in it. We&rsquo;ve all heard that every data type can be defined in terms of the kinds of operations that it supports. Well, what Church discovered is much more profound than that. A data type IS a function. In other words, an algebraic data type is not just a structure together with an algebra that collapses the structure. The algebra IS the structure.</p>

<p>Consider the boolean type. It is a disjoint union of True and False. What kinds of operations does this support? Well, you might want to do one thing if it&rsquo;s True, and another if it&rsquo;s False. Just like with our Tree, where we wanted to do one thing if it&rsquo;s a Leaf, and another thing if it&rsquo;s a Node, etc.</p>

<p>But it turns out that the boolean type IS the condition function. Consider the Church encoding of booleans:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>true  = λa.λb.a
</span><span class='line'>false = λa.λb.b</span></code></pre></td></tr></table></div></figure>


<p>So a boolean is actually a binary function. Given two terms, a boolean will yield the former term if it&rsquo;s true, and the latter term if it&rsquo;s false. What does this mean for our <code>Tree</code> type? It too is a function:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>empty = λa.λb.λc.a
</span><span class='line'>leaf  = λa.λb.λc.λx.b x
</span><span class='line'>node  = λa.λb.λc.λl.λr.c l r</span></code></pre></td></tr></table></div></figure>


<p>You can see that this gives you pattern matching for free. The <code>Tree</code> type is a function that takes three arguments:</p>

<p>A value to yield if the tree is empty.
A unary function to apply to an integer if it&rsquo;s a leaf.
A binary function to apply to the left and right subtrees if it&rsquo;s a node.
The type of such a function looks like this (Scala notation):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">T</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Tree</span> <span class="k">=&gt;</span> <span class="nc">Tree</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or equivalently:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Node</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span>
</span></code></pre></td></tr></table></div></figure>


<p>Translated to Java, we need this method on Tree:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                            <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                            <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>Function</code> interface is in the <code>java.util</code> package in Java 8, but you can definitely make it yourself in previous versions:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span> <span class="kd">public</span> <span class="n">B</span> <span class="nf">apply</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">);</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now our Tree code looks like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Constructor private so the type is sealed.</span>
</span><span class='line'>  <span class="kd">private</span> <span class="nf">Tree</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Empty</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Funciton</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Empty</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Leaf</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Leaf</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">left</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Tree</span> <span class="n">left</span><span class="o">,</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And we can do our pattern matching on the calling side:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">match</span><span class="o">((</span><span class="n">Empty</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Leaf</span> <span class="n">l</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is almost as terse as the Scala code, and very easy to understand. Everything is checked by the type system, and we are guaranteed that our patterns are exhaustive. This is an ideal solution.</p>

<h3>Conclusion</h3>

<p>With some slightly clever use of generics and a little help from our friends Church and Curry, we can indeed emulate structural pattern matching over algebraic data types in Java, to the point where it&rsquo;s almost as nice as a built-in language feature.</p>

<p>So throw away your Visitors and set fire to your GoF book.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/04/27/a-critique-of-impure-reason/">A Critique of Impure Reason</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2009-04-27'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2009</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Much has been made of the difference between &ldquo;object-oriented&rdquo; and &ldquo;functional&rdquo; programming. As much as I&rsquo;ve seen people talk about this difference, or some kind of imperative/functional dichotomy, I don&rsquo;t think it&rsquo;s a meaningful distinction. I find that the question of OO vs FP, or imperative vs functional, is not interesting or relevant. The relevant question is one of purity, or the distinction between pure and impure programming. That is, respectively, the kind of programming that eschews data mutation and side-effects as against the kind that embraces them.</p>

<p>Looking at pure (referentially transparent, purely functional) programming from a perspective of having accepted the premise of impurity, it&rsquo;s easy to be intimidated, and to see it as something foreign. Dijkstra once said that some programmers are &ldquo;mentally mutilated beyond hope of regeneration&rdquo;. I think that on one account, he was right, and that he was talking about this mental barrier of making the leap, from thinking about programming in terms of data mutation and effects, to the &ldquo;pure&rdquo; perspective. But I believe he was wrong on the other account. There is hope.</p>

<p>Contrary to what the last post indicated, this will not be a post about problems in &ldquo;object-oriented&rdquo; programming in particular, but about problems in impure programming in general. I will illustrate the issue of data mutation by way of two difficulties with it:</p>

<ul>
<li>It blurs the distinction between values and variables, such that a term can be both a value and a variable.</li>
<li>It introduces an artificial distinction between equality and identity.</li>
</ul>


<p>I will talk briefly about what the implications of each are, and what the alternative view is. But first I will discuss what I think motivates the impure perspective: an aversion to abstraction.</p>

<h2>The Primacy of the Machine</h2>

<p>In the early days of programming, there were no computers. The first programs were written, and executed, on paper. It wasn&rsquo;t until later that machines were first built that could execute programs automatically.</p>

<p>During the ascent of computers, an industry of professional computer programmers emerged. Perhaps because early computers were awkward and difficult to use, the focus of these professionals became less thinking about programs and more manipulating the machine.</p>

<p>Indeed, if you read the Wikipedia entry on &ldquo;Computer Program&rdquo;, it tells you that computer programs are &ldquo;instructions for a computer&rdquo;, and that &ldquo;a computer requires programs to function&rdquo;. This is a curious position, since it&rsquo;s completely backwards. It implies that programming is done in order to make computers do things, as a primary. I&rsquo;ll warrant that the article was probably written by a professional programmer.</p>

<p>But why does a computer need to function? Why does a computer even exist? The reality is that computers exist solely for the purpose of executing programs. The machine is not a metaphysical primary. Reality has primacy, a program is a description, an abstraction, a proof of some hypothesis about an aspect of reality, and the computer exists to deduce the implications of that fact for the pursuit of human values.</p>

<p>To say that a computer &ldquo;requires programs to function&rdquo; is not at all like saying that an automobile requires fuel. It&rsquo;s like saying that it needs a driver. While that&rsquo;s true, the driver doesn&rsquo;t exist for the sake of the car. The driver has somewhere to go and the car exists to serve that purpose.</p>

<h2>Shaping Programs in the Machine&rsquo;s Image</h2>

<p>There&rsquo;s a certain kind of programming that lends itself well to manipulating a computer at a low level. You must think in terms of copying data between registers and memory, and executing instructions based on the machine&rsquo;s current state. In this kind of activity, the programmer serves as the interpreter between the abstract algorithm and the physical machine. But this in itself is a mechanical task. We can instead write a program, once and for all, that performs the interpretation for us, and direct that program using a general-purpose programming language.</p>

<p>But what kind of structure will that language have? Ideally, we would be able to express programs in a natural and concise notation without regard to the machine. Such was the motivation behind LISP. It was designed as an implementation of the lambda calculus, a minimal formal system for expressing algorithms.</p>

<p>This is not what has happened with languages like Java, C++, and some other of today&rsquo;s most popular languages. The abstractions in those languages largely simulate the machine. You have mutable records, or objects, into which you copy data and execute instructions based on their current state. The identity of objects is based on their location in the computer&rsquo;s memory. You have constructs like &ldquo;factories&rdquo;, &ldquo;builders&rdquo;, &ldquo;generators&rdquo;&hellip; <em>machines</em>!</p>

<p>What we have is a generation of programmers accustomed to writing programs as if they were constructing a machine. We hear about &ldquo;engineering&rdquo; and &ldquo;architecture&rdquo; when talking about software. Indeed, as users, we interact with software using pictures of buttons, knobs, and switches. More machinery.</p>

<h2>Equality and Identity</h2>

<p>Programmers are generally used to thinking of equality and identity as distinct. For example, in Java, <code>(x == y)</code> means that the variable <code>x</code> holds a pointer to the same memory address as the variable <code>y</code>, i.e. that the variable <code>x</code> is identical with <code>y</code>. However, by convention, <code>x.equals(y)</code> means that the object at the memory address pointed to by <code>x</code> is equivalent in some sense to the object at the memory address pointed to by <code>y</code>, but <code>x</code> and <code>y</code> are not necessarily identical.</p>

<p>Note that the difference between the two can only be explained in terms of the underlying machine. We have to invoke the notion of memory addresses to understand what&rsquo;s going on, or else resort to an appeal to intuition with terms like &ldquo;same object&rdquo;, &ldquo;same instance&rdquo;, etc.</p>

<p>In a pure program, side-effects are disallowed. So a function is not allowed to mutate arguments or make calls to functions that have side-effects. So the result of every function is purely determined by the value of its arguments, and a function does nothing except compute a result. Think about the implications of that for a moment. Given that constraint, is there any reason to maintain a distinction between equality and identity? Consider this example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">String</span> <span class="n">y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the values referenced by <code>x</code> and <code>y</code> are forever immutable, what could it possibly mean for them to not be identical? In what meaningful sense are they not the &ldquo;same object&rdquo;?</p>

<p>Note that there&rsquo;s a philosophical connection here. The notion that every object carries an extradimensional identity that is orthogonal to its attributes is a very Platonic idea. The idea that an object has, in addition to its measurable attributes, a distinguished, eternal, noumenal identity. Contrast this with the Aristotelian view, in which an object&rsquo;s identity is precisely the sum of its attributes.</p>

<h2>Variables and Pseudovariables</h2>

<p>So we find that, given the mutability premise, a term in the language may be not be equal to itself even as it remains identical with itself. In a sense, this is because it&rsquo;s not entirely clear whether we are comparing values or variables when we compare a term. If that sounds a bit strange, consider the following snippet:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Foo</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">v</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Foo</span> <span class="nf">f</span><span class="o">(</span><span class="n">Foo</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">Foo</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="kt">boolean</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">);</span> <span class="c1">// true</span>
</span><span class='line'><span class="kt">boolean</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="na">v</span> <span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="na">v</span><span class="o">;</span> <span class="c1">// ???</span>
</span></code></pre></td></tr></table></div></figure>


<p>Even that short and ostensibly simple code snippet is difficult to comprehend properly, because the <code>f</code> method mutates its argument. It seems that since the first boolean is true, the same object appears on either side of the <code>==</code> operator, so <code>f(x)</code> is identical with <code>f(x)</code>. They&rsquo;re the &ldquo;same object&rdquo;. Even so, it is not clear that this &ldquo;same object&rdquo; is equal to itself. To figure out the value of <code>b</code>, you have to know some things about how the machine executes the program, not just what the program actually says. You can argue about pass-by-reference and pass-by-value, but these are terms that describe the machine, not the program.</p>

<p>You will note that the <code>Foo</code> type above is mutable in the sense that it has accessible components that can be assigned new values. But what does that mean? Is an object of type <code>Foo</code> a value or a variable? It seems to <em>have</em> a kind of pseudo-variable <code>v</code>. To clarify this, we can imagine that a variable holding a value of type <code>Foo</code> also holds a further value of type <code>int</code>. Assignment to a variable <code>x</code> of type <code>Foo</code> also assigns the variable <code>x.v</code> of type <code>int</code>, but the variable <code>x.v</code> can be assigned independently of <code>x</code>.</p>

<p>So data mutation is, ultimately, variable assignment. Above, <code>Foo</code> is mutated by assigning a value to the pseudo-variable <code>v</code>.</p>

<p>Now, I say pseudo-variable, because it&rsquo;s not obvious whether this is a value or a variable. A function that receives a value of type <code>Foo</code>, also receives the variable <code>Foo.v</code>, to which it can assign new values. So the variable is passed as if it were a value. Stated in terms of the machine, a pointer to a pointer is being passed, and the memory at that address can be mutated by writing another pointer to it. In terms of the program, the called function is able to <em>rebind a variable in the scope of the caller</em>.</p>

<p>This is why you have bugs, why programs are hard to debug, and software is difficult to extend. It&rsquo;s because programs are difficult to comprehend to the extent that they are impure. And the reason for that is that they are not sufficiently abstract. A writer of impure code is not operating on the level of abstraction of programming. He&rsquo;s operating at the level of abstraction of the machine.</p>

<h2>Thinking Pure Thoughts</h2>

<p>In a pure program, there are no side-effects at all. Every function is just that, a function from its arguments to its result. Values are immutable and eternal. A is A, and will always remain A. The only way to get from A to B is for there to be a function that takes A and returns B.</p>

<p>To a lot of programmers used to thinking in terms of mutable state, this perspective is completely baffling. And yet, most of them use immutable values all the time, without finding them particularly profound. For example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>In that example, 1 is an immutable value. The + operator doesn&rsquo;t modify the value of 1, nor of x, nor of y. It doesn&rsquo;t take the value 1 and turn it into a 2. Every integer is equal to and identical with itself, always and forever.</p>

<p>But what&rsquo;s special about integers? When adding a value to a list, a Java programmer will ordinarily do something like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">one</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>This modifies the list in place, so that any variable referencing it will change values. But why shouldn&rsquo;t lists be as immutable as integers? I&rsquo;m sure some readers just mumbled something about primitives and passing by reference versus passing by value. But why the distinction? If everything were immutable, you would never know if it were passed by value or reference under the covers. Nor would you care what&rsquo;s primitive and what isn&rsquo;t. For an immutable list, for example, the add function would not be able to modify the list in place, and so would return a new one:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">one</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>From this perspective, you can write programs that perform arithmetic with complex values as if they were primitive. But why stop with lists? When functions are pure, we can understand programs themselves as objects that are subject to calculation just like numbers in arithmetic, using simple and composable operators.</p>

<h2>Assignment in a Pure World</h2>

<p>Let&rsquo;s take a simple example of just such an operator. We&rsquo;ve talked about how mutation is really assignment. Now let&rsquo;s take the leap fully into the pure perspective, in which assignment is really just closure (pure functions with free variables). To illustrate, here is an example that all Java and C programmers are familiar with:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="n">t</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The familiar semicolon represents a combinator called &ldquo;bind&rdquo;. In Haskell, this operator is denoted <code>(&gt;&gt;=)</code>. In Scala, it&rsquo;s called <code>flatMap</code>. To better see how this works, here&rsquo;s a rough transliteration into Haskell:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">f</span> <span class="mi">1</span>
</span><span class='line'>  <span class="kr">where</span>
</span><span class='line'>    <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
</span><span class='line'>    <span class="n">g</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this isn&rsquo;t at all the kind of code you would normally write, but it serves to demonstrate the idea that assignment can be understood as binding the argument to a function. The Haskell code above roughly means:</p>

<p><em>Pass <code>1</code> to <code>f</code>, where <code>f</code> passes its argument to unchanged to <code>g</code>. And <code>g</code> adds <code>1</code> to its argument and passes the result to a function that adds <code>y</code> to its argument and passes that to <code>t</code>.</em></p>

<p>So in the Java version, we can understand everything after the first semicolon to be a <em>function</em> that takes an argument <code>x</code> and we happen to be passing it <code>1</code>. Everything after the second semicolon is a function that takes an argument <code>y</code> and we happen to be passing it <code>x</code> (which has the value <code>1</code>). And everything after the third semicolon is a function that takes an argument called <code>x</code> (shadowing the first <code>x</code>) and passes <code>x + y</code> to some function <code>t</code>.</p>

<p>Haskell is a purely functional language, and purity is enforced by its type system. If you haven&rsquo;t taken it for a spin, I challenge you to do so. For more on the benefits of purely functional programming, see &ldquo;Why Haskell Matters&rdquo;.</p>

<p>Of course, purity is not purely the prerogative of Haskell. Sure, Haskell enforces purity, but you can write pure code in any language. That Java code above is pure, you know. If this is all new to you, I challenge you to give purity a shot. In your favourite language, be it Java or something else, start using immutable datastructure in preference to mutable ones. Try thinking in terms of functions from arguments to results rather than in terms of mutation and effects. For Java, you might consider using the immutable datastructures provided by Functional Java or Google Collections. Scala also has immutable datastructures as part of its standard libraries.</p>

<p>It&rsquo;s time that we graduate from punching buttons and pulling levers — manipulating the machines. Here&rsquo;s to programming as it could be and ought to be.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/12/04/no-such-thing/">Objects, Identity, and Concept-formation</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2008-12-04'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2008</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Coming from a background in Pascal and C, during the 1990s, like most others, I became infatuated with Object-Oriented programming. I thought they were really on to something. It seemed intuitive. I read and re-read the <a href="http://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional/dp/0201633612">GoF book</a>. I became fluent in UML. I read Chris Alexander. I wrote factories and metafactories, and more class hierarchies than I&rsquo;ll ever count. I embraced Java eagerly, and XML moreso. But with experience came the realisation that I was solving the same problems over and over again. There was <a href="http://en.wikipedia.org/wiki/Combinatory_logic">some governing principle</a> that I was missing but knew I had to grasp if I were to progress in my chosen profession. I went back to the fundamentals. I learned about LISP, lamdba calculi, type theory, relational programming, <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, and <a href="http://en.wikipedia.org/wiki/Introduction_to_Objectivist_Epistemology">epistemology</a>. And I&rsquo;m still learning. But in integrating all of that into my existing knowledge, I discovered something that I found liberating:</p>

<p><em>There is no such thing as Object-Oriented programming.</em></p>

<p>I realise that I might risk starting a religious war here, but I don&rsquo;t intend to. If you think I&rsquo;m attacking you personally in some way, please stop reading and come back later with fresh eyes. Note that <strong>I&rsquo;m not saying that OO is a bad thing</strong>. I&rsquo;m saying that there isn&rsquo;t any special kind of programming that is object-oriented as against programming that isn&rsquo;t. It is a useless distinction, in exactly the same way that <a href="http://freedomkeys.com/ar-racism.htm">&ldquo;race&rdquo;</a> is a useless distinction. And holding on to a useless concept isn&rsquo;t good for anybody. The term &ldquo;object-oriented&rdquo; is at least honest in that it says what it implies, which is a frame of mind, an orientation of the programmer. However, the practical effect of this orientation is anti-conceptual, in that it displaces actual concepts like algebra, calculus, closure, function, identity, type, value, variable, etc. It fosters an aversion to abstraction. So you could say that there are object-orientated programmers.</p>

<h2>&ldquo;Object-Oriented&rdquo; as a non-concept</h2>

<p>Remember, you cannot be called upon to prove a negative. The burden of proof falls on whomever is claiming that there is such a thing as OO. But try as you might, <a href="http://www.paulgraham.com/reesoo.html">there&rsquo;s no objective definition of what &ldquo;object-oriented&rdquo; refers to</a>. It means anything you want, which is to say that it&rsquo;s rather meaningless. Peddlers of &ldquo;object methodology&rdquo; readily admit that &ldquo;object-oriented&rdquo; means different things to different people. To quote Aristotle: &ldquo;Not to have one meaning is to have no meaning, and if words have no meaning, our reasoning with one another, and indeed with ourselves, has been annihilated.&rdquo;</p>

<p>When I say that there&rsquo;s no such thing as OO, I mean, more precisely, that there exists some abstraction (or several) that is referred to as &ldquo;object-oriented&rdquo;, but that this abstraction has no actual referent in reality. It is an abstraction that is made in error. It is not necessary, and serves no cognitive purpose. It is &ldquo;not even false&rdquo;.</p>

<p>This is to say that it&rsquo;s not like the concept of Santa Claus, which is a fiction, a falsehood. OO is not a fiction, but a misintegration. It is a term that sounds like a concept, but denotes nothing more than a vague collection of disparate elements, any of which can be omitted, and none of which are essential.</p>

<h2>A Proper Method of Concept-Formation</h2>

<p>How is Object-Oriented a non-concept? Let&rsquo;s demonstrate that very cursorily. First, we have to explicitly identify what it means for a concept to be valid.</p>

<p><em>Valid concepts are arrived at by induction. </em>Induction is the process of integrating facts of reality by observing similarities and omitting particulars. Or, if you will, the process of applying logic to experience. Our induction must adhere to the corollary laws of <a href="http://en.wikipedia.org/wiki/Law_of_identity">identity</a>, <a href="http://en.wikipedia.org/wiki/Law_of_noncontradiction">noncontradiction</a>, and <a href="http://en.wikipedia.org/wiki/Law_of_excluded_middle">the excluded middle</a>, and it must observe <a href="http://aynrandlexicon.com/lexicon/causality.html">causality</a>.</p>

<p>Note that a correct concept of concepts is the vehicle and not the cargo of this post. In brief, a valid concept or theory must meet the following criteria (hat tip: <a href="http://www.theobjectivestandard.com/issues/2007-spring/induction-experimental-method.asp">David Harriman</a>):</p>

<ol>
<li>It must be derived from observations by a valid method (by logical induction from experience or experiment as described above). A valid concept can have no arbitrary elements and no relations that are unsupported by the facts being integrated.</li>
<li>It must form an integrated whole in which every part supports every other. It cannot be a conglomeration of independent parts that are freely adjusted to fit a given situation.</li>
<li>It must be no more and no less general than required to meet criteria 1 and 2.</li>
</ol>


<p><strong>OO doesn&rsquo;t meet criterion #1</strong>. There&rsquo;s nothing about the nature of programming that gives rise to a concept of object-orientation. Rather, the notion is sparked by the desire to make an analogy between manipulating physical objects in the real world and manipulating abstract entities in the computer. The motivation is understandable, to help people think about programs in the same way that they are used to reasoning about physical objects. But the analogy isn&rsquo;t warranted by the facts, and therefore it is arbitrary. The concepts simply don&rsquo;t transfer, because they are abstractions over entities of a different kind. The mistake is to use the concepts anyway, choosing the illusion that software is like physical systems rather than understanding the actual nature of programs.</p>

<p><strong>OO doesn&rsquo;t meet criterion #2</strong>: There&rsquo;s no consistent definition of object-orientation. It&rsquo;s a loose grab-bag in which nothing is essential. Even if you start removing things, it&rsquo;s not at all clear at what point your programming stops being object-oriented. One would think that it&rsquo;s at the point where you stop programming with objects, but that&rsquo;s merely begging the question since it&rsquo;s not clear what kind of entity is an object and what kind of entity isn&rsquo;t. We are to rely on intuition alone in discovering that. What&rsquo;s more, some of the contents of the &ldquo;object-oriented&rdquo; bag contradict one another (both inheritance and mutation contradict encapsulation, for example).</p>

<h2>Repairing the Disorientation</h2>

<p>Of course, it does no good to tear down the cognitive package-deal that is &ldquo;object-oriented&rdquo; if you don&rsquo;t replace it with something. If you entered a village of <a href="http://www.smurf.com/">little blue creatures</a> and convinced them that the term &ldquo;smurf&rdquo; had no cognitive utility, you would have to teach them a whole host of concepts to use in its stead. There are two main ideas that the anti-concept &ldquo;object-oriented&rdquo; annihilates:</p>

<ol>
<li>It introduces the false dichotomy of identity as apart from equivalence.</li>
<li>It blurs the distinction between values and variables.</li>
</ol>


<p>I will elaborate on each of these points in two follow-up posts. Stay tuned.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Read my book</h1>
<a href="http://manning.com/bjarnason"><img src="/images/FPinScalaCover.png" width="553px" height="694px"></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/">An Adjunction That Induces the Reader Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/23/a-scala-comonad-tutorial/">A Scala Comonad Tutorial, Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/18/easy-performance-wins-with-scalaz/">Easy Performance Wins With Scalaz</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/16/pulling-out-of-functional-programming-in-java/">Pulling Out of Functional Programming in Java</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/06/a-companion-booklet-to-functional-programming-in-scala/">A Companion Booklet to FPiS</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/runarorama">@runarorama</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'runarorama',
            count: 4,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Rúnar Bjarnason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
