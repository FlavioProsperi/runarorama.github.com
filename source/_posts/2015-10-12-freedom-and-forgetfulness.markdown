---
layout: post
title: "Freedom and Forgetfulness"
date: 2015-10-12 23:13:54 -0400
comments: true
author: Rúnar
categories: 
commentIssueId: 21
---

I've been having fun exploring adjunctions lately and thinking about how we can take a monad apart and compose it the other way to get a comonad, and vice versa. Often I'll find that a comonad counterpart of a given monad gives an interesting perspective on that monad, and ditto for a monad cousin to a given comonad.

## The monad for monoids

Let's take an example. There is a category of monoids _Mon_ with monoids as objects and monoid homomorphisms as arrows between them. Then there is a functor from _Set_ to _Mon_ that takes any ordinary type `A` to the _free monoid_ generated by `A`. This is just the `List[A]` type together with concatenation as the multiplication and the empty list as the identity element.

This free functor has a right adjoint that takes any monoid `M` in _Mon_ to its _underlying set_ `M`. That is, this right adjoint "forgets" that `M` is a monoid, leaving us with just an ordinary type.

If we compose these two functors, we get a monad. If we start with a type `A`, get its free monoid (the `List[A]` monoid), and then go from there to the underlying type of the free monoid, we end up with the type `List[A]`. The `unit` of our adjunction is then a function from any given type `A` to the type `List[A]`.

``` scala
def unit[A](a: A): List[A] = List(a)
```

### Structure ⊣ Interpretation

But then what is the `counit`? Remember that for any adjunction, we can compose the functors one way to get a monad, and compose them the other way to get a comonad.

In that case we have to start with a monoid `M`, then "forget", giving us the plain type `M`. Then we take the free monoid of that to end up with the `List[M]` monoid.

But notice that we are now in the monoid category. In that category, `List` is a comonad. And since we're in the category of monoids, the `counit` has to be a _monoid homomorphism_. It goes from the free monoid `List[A]` to the monoid `A`:

``` scala
def counit[A:Monoid](as: List[A]): A =
  as.foldRight(Monoid[A].zero)(Monoid[A].append)
```

If we send the `counit` for this comonad over to the _Set_ category, we get the `join` for our monad:

``` scala
def join[A](as: List[List[A]]): List[A] = counit(as)
```

And to get the `duplicate` or `extend` operation in the comonad, we just turn the crank on the adjunction:

``` scala
def duplicate[A](as: List[A]): List[List[A]] =
  as.map(unit(_))
```

The `duplicate` just puts each element into its own sublist. With regard to `extend`, this just means that given any catamorphism on `List`, we can turn that into a homomorphism on free monoids.

``` scala
def extend[A,B](as: List[A])(f: List[A] => B): List[B] =
  as.map(x => f(unit(x)))
```

All the interesting parts of `List` are the parts that make it a monoid, and our comonad here is already in a category full of monoids. Therefore the coKleisli composition in this comonad is kind of uninteresting. All it's saying is that if we can fold a `List[A]` to a `B`, and a `List[B]` to a `C`, then we can fold a `List[A]` to a `C`, by considering each element as a singleton list.

## Forget ⊣ Cofree

Let's now consider another category, call it _End(Set)_, which is the _category of endofunctors_ in _Set_.

The arrows in this category are natural transformations:

``` scala
trait ~>[F[_],G[_]] {
  def apply[A](x: F[A]): G[A]
}
```

There's another category, _Com_, which is the _category of comonads_ on _Set_. The arrows here are _comonad homomorphisms_. A comonad homomorphism from `F` to `G` is a natural transformation `f: F ~> G` satisfying the homomorphism law:

``` scala
f(x).duplicate == f(x.duplicate) map f
```

There is a forgetful functor `Forget: Com -> End(Set)` that takes a comonad to its underlying endofunctor (forgetting that it's a comonad). And this functor has a _right_ adjoint `Cofree: End(Set) -> Com` which generates a cofree comonad on a given endofunctor `F`. This is the following data type:

``` scala
case class Cofree[F[_],A](head: A, tail: F[Cofree[F,A]])
```

Note that not only is the endofunctor `Cofree[F,?]` a comonad (in _Set_) for any functor `F`, but the higher-order type constructor `Cofree` is itself is a comonad in the endofunctor category. It's this latter comonad that is induced by the `Forget ⊣ Cofree` adjunction. That is, we start at an endofunctor `F`, then go to comonads via `Cofree[F,?]`, then back to endofunctors via `Forget`.

The `unit` for this adjunction is then a comonad homomorphism. Remember, this is the `unit` for a monad in the category _Com_ of comonads:

``` scala
def unit[F[_]:Comonad,A](x: F[A]): Cofree[F,A] =
  Cofree(x.counit, x.extend(unit(_)))
}
```

This will start with a value of type `F[A]` in the comonad `F`, and then _unfold_ an `F`-branching stream from it. Note that the first level of this will have the same structure as `x`.

If we take `unit` across to the _End(Set)_ category, we get the `duplicate` for our comonad:

``` scala
def duplicate[F[_],A](c: Cofree[F,A]): Cofree[Cofree[F,?],A] =
  unit(c)
```

Note that this is _not_ the `duplicate` for the `Cofree[F,?]` comonad. It's the duplicate for `Cofree` itself which is a comonad in an endofunctor category.

Turning the crank on the adjunction, the `counit` for this comonad now has to be the inverse of our `unit`. It takes the heads of all the branches of the given `F`-branching stream.

``` scala
def counit[F[_]:Functor,A](c: Cofree[F,A]): F[A] =
  c.tail.map(_.head)
}
```

Sending that over to the comonad category, we get the `join` for our monad:

``` scala
def join[F[_]:Comonad,A](c: Cofree[Cofree[F,?],A]): Cofree[F,A] =
  counit(c)
```


